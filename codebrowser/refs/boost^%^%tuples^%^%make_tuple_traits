<def f='include/boost/tuple/detail/tuple_basic.hpp' l='637'/>
<def f='include/boost/tuple/detail/tuple_basic.hpp' l='661'/>
<def f='include/boost/tuple/detail/tuple_basic.hpp' l='671'/>
<def f='include/boost/tuple/detail/tuple_basic.hpp' l='676'/>
<def f='include/boost/tuple/detail/tuple_basic.hpp' l='680'/>
<def f='include/boost/tuple/detail/tuple_basic.hpp' l='685'/>
<def f='include/boost/tuple/detail/tuple_basic.hpp' l='690'/>
<def f='include/boost/tuple/detail/tuple_basic.hpp' l='695'/>
<def f='include/boost/tuple/detail/tuple_basic.hpp' l='700'/>
<size>1</size>
<doc f='include/boost/tuple/detail/tuple_basic.hpp' l='648'>// The is_function test was there originally for plain function types,
// which can&apos;t be stored as such (we must either store them as references or
// pointers). Such a type could be formed if make_tuple was called with a
// reference to a function.
// But this would mean that a const qualified function type was formed in
// the make_tuple function and hence make_tuple can&apos;t take a function
// reference as a parameter, and thus T can&apos;t be a function type.
// So is_function test was removed.
// (14.8.3. says that type deduction fails if a cv-qualified function type
// is created. (It only applies for the case of explicitly specifying template
// args, though?)) (JJ)</doc>
<doc f='include/boost/tuple/detail/tuple_basic.hpp' l='667'>// Arrays can&apos;t be stored as plain types; convert them to references.
// All arrays are converted to const. This is because make_tuple takes its
// parameters as const T&amp; and thus the knowledge of the potential
// non-constness of actual argument is lost.</doc>
